#include <fstream>

#include "Robot.h"
#include "Commands/CMG_AutoGenerated.h"

std::shared_ptr<Drivetrain> Robot::drivetrain;
std::unique_ptr<OI> Robot::oi;
std::shared_ptr<frc::Compressor> Robot::compressor;
std::shared_ptr<NavXSubsystem> Robot::navXSubsystem;
std::shared_ptr<UltrasonicSubsystem> Robot::ultrasonicSubsystem;
std::shared_ptr<Cube> Robot::cube;
std::shared_ptr<Climber> Robot::climber;
std::shared_ptr<NavXPIDSource> Robot::navxPidSource;
std::shared_ptr<Elevator> Robot::elevator;

void Robot::RobotInit() {
	std::cout << "Robot Init" << std::endl;
	RobotMap::init();
    drivetrain.reset(new Drivetrain());
    ultrasonicSubsystem.reset(new UltrasonicSubsystem());
    navxPidSource.reset(new NavXPIDSource());
    elevator.reset(new Elevator());
    RobotMap::navXTurnController.reset(new frc::PIDController(
    		NavXSubsystem::NAVX_P_VALUE,
			NavXSubsystem::NAVX_I_VALUE,
			NavXSubsystem::NAVX_D_VALUE,
			NavXSubsystem::NAVX_F_VALUE,
			navxPidSource.get(),
			drivetrain.get()
		));
		RobotMap::navXTurnController->SetInputRange(-180.0f,  180.0f);
		RobotMap::navXTurnController->SetOutputRange(-1.0, 1.0);
		RobotMap::navXTurnController->SetAbsoluteTolerance(0.5f);
		RobotMap::navXTurnController->SetContinuous(true);
	compressor.reset(new frc::Compressor());
	cube.reset(new Cube());
	climber.reset (new Climber());
	oi.reset(new OI());
	lw = frc::LiveWindow::GetInstance();
//	lw->Add(RobotMap::navXTurnController);
	lw->Add(RobotMap::drivetrainChassis);
}
void Robot::RobotPeriodic() {
//	std::cout << "Robto Periodic" << std::endl;
	SmartDashboard::PutBoolean("Is Connected",RobotMap::navX->IsConnected());
	SmartDashboard::PutBoolean("Is Moving",RobotMap::navX->IsMoving());
	SmartDashboard::PutBoolean("Is Rotating",RobotMap::navX->IsRotating());
	SmartDashboard::PutNumber("GetYaw",RobotMap::navX->GetYaw());
	SmartDashboard::PutNumber("GetRoll",RobotMap::navX->GetRoll());
	SmartDashboard::PutNumber("GetPitch",RobotMap::navX->GetPitch());

	SmartDashboard::PutNumber("Subsystem Get Left Encoder", Robot::drivetrain->GetLeftEncoder());
	SmartDashboard::PutNumber("Raw Left Encoder", RobotMap::drivetrainLeftEncoder->Get());
	SmartDashboard::PutNumber("Subsystem Get Right Encoder", Robot::drivetrain->GetRightEncoder());
	SmartDashboard::PutNumber("Raw Right Encoder", RobotMap::drivetrainRightEncoder->Get());

	SmartDashboard::PutNumber("Front Ultrasonic distance", RobotMap::ultrasonicFrontLeft->GetDistance());
	SmartDashboard::PutNumber("Rear Ultrasonic distance", RobotMap::ultrasonicRearLeft->GetDistance());
	SmartDashboard::PutNumber("Average Distance Away", Robot::ultrasonicSubsystem->GetAverageDistance(Util::RobotSide::leftSide));
	SmartDashboard::PutNumber ("Voltage Returned Front", RobotMap::ultrasonicFrontLeft->GetAnalogInput()->GetAverageVoltage());
	SmartDashboard::PutNumber ("Voltage Returned Rear", RobotMap::ultrasonicRearLeft->GetAnalogInput()->GetAverageVoltage());
	SmartDashboard::PutNumber("Starting Distance", Robot::ultrasonicSubsystem->m_startingDistance);

	SmartDashboard::PutBoolean("Top Limit Switch" , RobotMap::elevatorTopSwitch->Get());
	SmartDashboard::PutBoolean("Bottom Limit Switch" , RobotMap::elevatorBottomSwitch->Get());
	SmartDashboard::PutNumber("Raw Elevator Clicks" , RobotMap::elevatorEncoder->Get());


}
void Robot::DisabledInit(){
	compressor->SetClosedLoopControl(false);
	RobotMap::navX->Reset();
	RobotMap::navX->ResetDisplacement();
	drivetrain->SetPIDEnabled(false);
	//drivetrain->GetPIDOutput();
	autonomousCommand.release(); // Make auto command null again.
}

void Robot::DisabledPeriodic() {
	std::cout << "I'm Disabled!" << std::endl;
	Scheduler::GetInstance()->Run();

}

void Robot::PickAuto() {
	std::string gameMessage = frc::DriverStation::GetInstance().GetGameSpecificMessage();
	if(gameMessage.length() == 0) return;
	std::vector<char> balanceStates(gameMessage.begin(), gameMessage.end());

	StartLocation startingPosition = StartLocation::unknown;
	bool doSwitch = false;
	bool doScale = false;

	std::vector<frc::Command*> commands;

	if (balanceStates.empty()) {
		std::cout << "There's no auto things. Go yell at the FMS. Maybe...Just maybe that'll help" << std::endl;
	}

	std::ifstream ifs("/home/lvuser/Autonomous.txt");
	if (!ifs.good()) {
		std::cout << "ERROR: NO AUTO FILE FOUND. GO HUDDLE IN THE CORNER AND RESEARCH IT" << std::endl;
		std::cout << "So I'm gonna drive straight and get you some points anyway" << std::endl;
		ifs.close();
		//drive forward and fall in style!
		//TODO Add in the drive straight command group
		return;
	}
	while (!ifs.eof()) {
		std::string lastPart;
		std::string firstPart;
		std::getline(ifs, firstPart, ':');
		std::getline(ifs, lastPart);
		while (lastPart[0] == ' ') {
			lastPart = lastPart.substr(1);
		}
		if (!ifs.eof()) {
			lastPart = lastPart.substr(0, lastPart.size() - 1);
		}
		std::cout << firstPart << " - " << lastPart << std::endl;
		if (firstPart == "StartPosition") {
			if (lastPart == "left") {
				startingPosition = StartLocation::left;
			} else if (lastPart == "center") {
				startingPosition = StartLocation::center;
			} else if (lastPart == "right") {
				startingPosition = StartLocation::right;
			} else {
				std::cout << "That's not an option for starting positions. Don't feel like doing anything now" << std::endl;
				startingPosition = StartLocation::unknown;
			}
		} else if (firstPart == "DoSwitch") {
			if (true) {
				doSwitch = true;
			} else if (false) {
				doSwitch = false;
			} else {
				std::cout << "That's not an option for doing the switch. Need more zip-ties to accomplish anything" << std::endl;
				doSwitch = false;
			}
		} else if (firstPart == "DoScale") {
			if (true) {
				doScale = true;
			} else if (false) {
				doScale = false;
			} else {
				std::cout << "That's not an option for doing the scale. Is everything plugged in?" << std::endl;
				doScale = false;
			}
		}
	}
	if (startingPosition == StartLocation::unknown) {
		std::cout << "You chose not to do anything so I'm gonna drive straight and get you some points anyway" << std::endl;
		//TODO drive straight cause we got nothings
	} else if (startingPosition == StartLocation::left) {
		if (doScale == true && doSwitch == true) {
			//Gotta check it all cause we're try-hards
			if (balanceStates[0] == 'L' && balanceStates[1] == 'L') {
				std::cout << "They're on the same side, this won't be as hard...But still unlikely" << std::endl;
				//TODO Add in the appropriate auto
			} else if (balanceStates[0] == 'L' && balanceStates[1] == 'R') {
				std::cout << "You're trying to do something that seems unlikely....Reconsider?" << std::endl;
				//TODO Add in the appropriate auto
			} else if (balanceStates[0] == 'R' && balanceStates[1] == 'L') {
				std::cout << "You're trying to do something that seems even more unlikely....Reconsider?" << std::endl;
				//TODO Add in the appropriate auto
			} else if (balanceStates[0] == 'R' && balanceStates[1] == 'R') {
				std::cout << "You're really determined to do this aren't you. I guess if you're sure...." << std::endl;
				//TODO Add in the appropriate auto
			} else {
				std::cout << "Something went wrong somehow even with all these checks....Gonna drive straight anyway" << std::endl;
				//TODO Add in the drive straight auto
			}
		} else if (doScale == true && doSwitch == false) {
			//Gonna ignore the switch stuff and make this easier
			if (balanceStates[1] == 'L') {
				std::cout << "Our team got the switch down so we gonna go zoom left and be tall" << std::endl;
				//TODO Add in the appropriate auto
			} else if (balanceStates[1] == 'R') {
				std::cout << "Our team got the switch down so we gonna go zoom right and be tall" << std::endl;
				//TODO Add in the appropriate auto
			} else {
				std::cout << "Something went wrong somehow even with all these checks....Gonna drive straight anyway" << std::endl;
				//TODO Add in the drive straight auto
			}
		} else if (doScale == false && doSwitch == true) {
			//Gonna ignore the scale stuff and make this easier
			if (balanceStates[0] == 'L') {
				std::cout << "Gonna zoom and be short on the left side I guess..." << std::endl;
				//TODO Add in the appropriate auto
			} else if (balanceStates[0] == 'R') {
				std::cout << "Gonna zoom zig-zag style and go be short on the right side" << std::endl;
				//TODO Add in the appropriate auto
			} else {
				std::cout << "Something went wrong somehow even with all these checks....Gonna drive straight anyway" << std::endl;
				//TODO Add in the drive straight auto
			}
		}
	} else if (startingPosition == StartLocation::right) {

	} else if (startingPosition == StartLocation::center) {
		if (balanceStates[0] == 'L') {
			if (doSwitch == true) {
				std::cout << "I'm in the middle, zooming left!" << std::endl;
				//TODO Add the center left auto
			} else {
				std::cout << "You chose not to do anything so I'm gonna drive straight and get you some points anyway" << std::endl;
				//TODO Add the drive straight auto
			}
		} else if (balanceStates[0] == 'R') {
			if (doSwitch == true) {
				std::cout << "I'm in the middle, zooming right!" << std::endl;
				//TODO Add the center right auto
			} else {
				std::cout << "You chose not to do anything so I'm gonna drive straight and get you some points" << std::endl;
				//TODO Add the drive straight auto
			}
		}
	} else {
		std::cout << "You dun goofed you ignorant peasant" << std::endl;
	}
	autonomousCommand.reset(new CMG_AutoGenerated(commands));
}

void Robot::AutonomousInit() {
	Robot::drivetrain->ResetEncoders();
	this->PickAuto();
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	if(autonomousCommand.get() == nullptr){
		this->PickAuto();
	}
	Scheduler::GetInstance()->Run();


}

void Robot::TeleopInit() {
	Robot::drivetrain->ResetEncoders();
	compressor->SetClosedLoopControl(true);
	if (autonomousCommand.get() != nullptr)
			autonomousCommand->Cancel();
}

void Robot::TeleopPeriodic() {
	Scheduler::GetInstance()->Run();
	}

void Robot::TestInit() {
	Robot::drivetrain->ResetEncoders();
	drivetrain->SetPIDEnabled(false);
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();

	drivetrain->SetPIDSetpoint(90);
}

void Robot::TestPeriodic() {
	Scheduler::GetInstance()->Run();

	if(drivetrain->IsPIDEnabled()){
		double output = drivetrain->GetPIDOutput();
		SmartDashboard::PutNumber("PID Input", navxPidSource->PIDGet());
		SmartDashboard::PutNumber("PID Output", output);
		drivetrain->DriveRobotTank(-output,output);
	}else{
		drivetrain->DriveRobotTank(0,0);
	}
	//lw->Run();
}

START_ROBOT_CLASS(Robot);
